"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_tsparticles_shape-image_browser_GifUtils_Utils_js"],{

/***/ "(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/ByteStream.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tsparticles/shape-image/browser/GifUtils/ByteStream.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ByteStream: function() { return /* binding */ ByteStream; }\n/* harmony export */ });\nclass ByteStream {\n    getString(count) {\n        const slice = this.data.slice(this.pos, this.pos + count);\n        this.pos += slice.length;\n        return slice.reduce((acc, curr)=>acc + String.fromCharCode(curr), \"\");\n    }\n    nextByte() {\n        return this.data[this.pos++];\n    }\n    nextTwoBytes() {\n        const increment = 2, previous = 1, shift = 8;\n        this.pos += increment;\n        return this.data[this.pos - increment] + (this.data[this.pos - previous] << shift);\n    }\n    readSubBlocks() {\n        let blockString = \"\", size = 0;\n        const minCount = 0, emptySize = 0;\n        do {\n            size = this.data[this.pos++];\n            for(let count = size; --count >= minCount; blockString += String.fromCharCode(this.data[this.pos++])){}\n        }while (size !== emptySize);\n        return blockString;\n    }\n    readSubBlocksBin() {\n        let size = this.data[this.pos], len = 0;\n        const emptySize = 0, increment = 1;\n        for(let offset = 0; size !== emptySize; offset += size + increment, size = this.data[this.pos + offset]){\n            len += size;\n        }\n        const blockData = new Uint8Array(len);\n        size = this.data[this.pos++];\n        for(let i = 0; size !== emptySize; size = this.data[this.pos++]){\n            for(let count = size; --count >= emptySize; blockData[i++] = this.data[this.pos++]){}\n        }\n        return blockData;\n    }\n    skipSubBlocks() {\n        for(const increment = 1, noData = 0; this.data[this.pos] !== noData; this.pos += this.data[this.pos] + increment){}\n        this.pos++;\n    }\n    constructor(bytes){\n        this.pos = 0;\n        this.data = new Uint8ClampedArray(bytes);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHNwYXJ0aWNsZXMvc2hhcGUtaW1hZ2UvYnJvd3Nlci9HaWZVdGlscy9CeXRlU3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQTtJQUtUQyxVQUFVQyxLQUFLLEVBQUU7UUFDYixNQUFNQyxRQUFRLElBQUksQ0FBQ0MsSUFBSSxDQUFDRCxLQUFLLENBQUMsSUFBSSxDQUFDRSxHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHLEdBQUdIO1FBQ25ELElBQUksQ0FBQ0csR0FBRyxJQUFJRixNQUFNRyxNQUFNO1FBQ3hCLE9BQU9ILE1BQU1JLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxNQUFNRSxPQUFPQyxZQUFZLENBQUNGLE9BQU87SUFDeEU7SUFDQUcsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDUixJQUFJLENBQUMsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDaEM7SUFDQVEsZUFBZTtRQUNYLE1BQU1DLFlBQVksR0FBR0MsV0FBVyxHQUFHQyxRQUFRO1FBQzNDLElBQUksQ0FBQ1gsR0FBRyxJQUFJUztRQUNaLE9BQU8sSUFBSSxDQUFDVixJQUFJLENBQUMsSUFBSSxDQUFDQyxHQUFHLEdBQUdTLFVBQVUsR0FBSSxLQUFJLENBQUNWLElBQUksQ0FBQyxJQUFJLENBQUNDLEdBQUcsR0FBR1UsU0FBUyxJQUFJQyxLQUFJO0lBQ3BGO0lBQ0FDLGdCQUFnQjtRQUNaLElBQUlDLGNBQWMsSUFBSUMsT0FBTztRQUM3QixNQUFNQyxXQUFXLEdBQUdDLFlBQVk7UUFDaEMsR0FBRztZQUNDRixPQUFPLElBQUksQ0FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1lBQzVCLElBQUssSUFBSUgsUUFBUWlCLE1BQU0sRUFBRWpCLFNBQVNrQixVQUFVRixlQUFlUixPQUFPQyxZQUFZLENBQUMsSUFBSSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDQyxHQUFHLEdBQUcsRUFBRyxDQUN2RztRQUNKLFFBQVNjLFNBQVNFLFdBQVc7UUFDN0IsT0FBT0g7SUFDWDtJQUNBSSxtQkFBbUI7UUFDZixJQUFJSCxPQUFPLElBQUksQ0FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ0MsR0FBRyxDQUFDLEVBQUVrQixNQUFNO1FBQ3RDLE1BQU1GLFlBQVksR0FBR1AsWUFBWTtRQUNqQyxJQUFLLElBQUlVLFNBQVMsR0FBR0wsU0FBU0UsV0FBV0csVUFBVUwsT0FBT0wsV0FBV0ssT0FBTyxJQUFJLENBQUNmLElBQUksQ0FBQyxJQUFJLENBQUNDLEdBQUcsR0FBR21CLE9BQU8sQ0FBRTtZQUN0R0QsT0FBT0o7UUFDWDtRQUNBLE1BQU1NLFlBQVksSUFBSUMsV0FBV0g7UUFDakNKLE9BQU8sSUFBSSxDQUFDZixJQUFJLENBQUMsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDNUIsSUFBSyxJQUFJc0IsSUFBSSxHQUFHUixTQUFTRSxXQUFXRixPQUFPLElBQUksQ0FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHLENBQUU7WUFDOUQsSUFBSyxJQUFJSCxRQUFRaUIsTUFBTSxFQUFFakIsU0FBU21CLFdBQVdJLFNBQVMsQ0FBQ0UsSUFBSSxHQUFHLElBQUksQ0FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUNDLEdBQUcsR0FBRyxDQUFFLENBQ3JGO1FBQ0o7UUFDQSxPQUFPb0I7SUFDWDtJQUNBRyxnQkFBZ0I7UUFDWixJQUFLLE1BQU1kLFlBQVksR0FBR2UsU0FBUyxHQUFHLElBQUksQ0FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUNDLEdBQUcsQ0FBQyxLQUFLd0IsUUFBUSxJQUFJLENBQUN4QixHQUFHLElBQUksSUFBSSxDQUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDQyxHQUFHLENBQUMsR0FBR1MsVUFBVyxDQUNuSDtRQUNBLElBQUksQ0FBQ1QsR0FBRztJQUNaO0lBN0NBeUIsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxDQUFDMUIsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDRCxJQUFJLEdBQUcsSUFBSTRCLGtCQUFrQkQ7SUFDdEM7QUEyQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0c3BhcnRpY2xlcy9zaGFwZS1pbWFnZS9icm93c2VyL0dpZlV0aWxzL0J5dGVTdHJlYW0uanM/OTlkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQnl0ZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYnl0ZXMpO1xuICAgIH1cbiAgICBnZXRTdHJpbmcoY291bnQpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgY291bnQpO1xuICAgICAgICB0aGlzLnBvcyArPSBzbGljZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzbGljZS5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgU3RyaW5nLmZyb21DaGFyQ29kZShjdXJyKSwgXCJcIik7XG4gICAgfVxuICAgIG5leHRCeXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgIH1cbiAgICBuZXh0VHdvQnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IGluY3JlbWVudCA9IDIsIHByZXZpb3VzID0gMSwgc2hpZnQgPSA4O1xuICAgICAgICB0aGlzLnBvcyArPSBpbmNyZW1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5wb3MgLSBpbmNyZW1lbnRdICsgKHRoaXMuZGF0YVt0aGlzLnBvcyAtIHByZXZpb3VzXSA8PCBzaGlmdCk7XG4gICAgfVxuICAgIHJlYWRTdWJCbG9ja3MoKSB7XG4gICAgICAgIGxldCBibG9ja1N0cmluZyA9IFwiXCIsIHNpemUgPSAwO1xuICAgICAgICBjb25zdCBtaW5Db3VudCA9IDAsIGVtcHR5U2l6ZSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IHNpemU7IC0tY291bnQgPj0gbWluQ291bnQ7IGJsb2NrU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5kYXRhW3RoaXMucG9zKytdKSkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChzaXplICE9PSBlbXB0eVNpemUpO1xuICAgICAgICByZXR1cm4gYmxvY2tTdHJpbmc7XG4gICAgfVxuICAgIHJlYWRTdWJCbG9ja3NCaW4oKSB7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5kYXRhW3RoaXMucG9zXSwgbGVuID0gMDtcbiAgICAgICAgY29uc3QgZW1wdHlTaXplID0gMCwgaW5jcmVtZW50ID0gMTtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgc2l6ZSAhPT0gZW1wdHlTaXplOyBvZmZzZXQgKz0gc2l6ZSArIGluY3JlbWVudCwgc2l6ZSA9IHRoaXMuZGF0YVt0aGlzLnBvcyArIG9mZnNldF0pIHtcbiAgICAgICAgICAgIGxlbiArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrRGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIHNpemUgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBzaXplICE9PSBlbXB0eVNpemU7IHNpemUgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK10pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gc2l6ZTsgLS1jb3VudCA+PSBlbXB0eVNpemU7IGJsb2NrRGF0YVtpKytdID0gdGhpcy5kYXRhW3RoaXMucG9zKytdKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrRGF0YTtcbiAgICB9XG4gICAgc2tpcFN1YkJsb2NrcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbmNyZW1lbnQgPSAxLCBub0RhdGEgPSAwOyB0aGlzLmRhdGFbdGhpcy5wb3NdICE9PSBub0RhdGE7IHRoaXMucG9zICs9IHRoaXMuZGF0YVt0aGlzLnBvc10gKyBpbmNyZW1lbnQpIHtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcysrO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJCeXRlU3RyZWFtIiwiZ2V0U3RyaW5nIiwiY291bnQiLCJzbGljZSIsImRhdGEiLCJwb3MiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibmV4dEJ5dGUiLCJuZXh0VHdvQnl0ZXMiLCJpbmNyZW1lbnQiLCJwcmV2aW91cyIsInNoaWZ0IiwicmVhZFN1YkJsb2NrcyIsImJsb2NrU3RyaW5nIiwic2l6ZSIsIm1pbkNvdW50IiwiZW1wdHlTaXplIiwicmVhZFN1YkJsb2Nrc0JpbiIsImxlbiIsIm9mZnNldCIsImJsb2NrRGF0YSIsIlVpbnQ4QXJyYXkiLCJpIiwic2tpcFN1YkJsb2NrcyIsIm5vRGF0YSIsImNvbnN0cnVjdG9yIiwiYnl0ZXMiLCJVaW50OENsYW1wZWRBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/ByteStream.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/Constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tsparticles/shape-image/browser/GifUtils/Constants.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InterlaceOffsets: function() { return /* binding */ InterlaceOffsets; },\n/* harmony export */   InterlaceSteps: function() { return /* binding */ InterlaceSteps; }\n/* harmony export */ });\nconst InterlaceOffsets = [\n    0,\n    4,\n    2,\n    1\n];\nconst InterlaceSteps = [\n    8,\n    8,\n    4,\n    2\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHNwYXJ0aWNsZXMvc2hhcGUtaW1hZ2UvYnJvd3Nlci9HaWZVdGlscy9Db25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxtQkFBbUI7SUFBQztJQUFHO0lBQUc7SUFBRztDQUFFLENBQUM7QUFDdEMsTUFBTUMsaUJBQWlCO0lBQUM7SUFBRztJQUFHO0lBQUc7Q0FBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdHNwYXJ0aWNsZXMvc2hhcGUtaW1hZ2UvYnJvd3Nlci9HaWZVdGlscy9Db25zdGFudHMuanM/ZGJkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgSW50ZXJsYWNlT2Zmc2V0cyA9IFswLCA0LCAyLCAxXTtcbmV4cG9ydCBjb25zdCBJbnRlcmxhY2VTdGVwcyA9IFs4LCA4LCA0LCAyXTtcbiJdLCJuYW1lcyI6WyJJbnRlcmxhY2VPZmZzZXRzIiwiSW50ZXJsYWNlU3RlcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/Constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/Utils.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tsparticles/shape-image/browser/GifUtils/Utils.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeGIF: function() { return /* binding */ decodeGIF; },\n/* harmony export */   drawGif: function() { return /* binding */ drawGif; },\n/* harmony export */   getGIFLoopAmount: function() { return /* binding */ getGIFLoopAmount; },\n/* harmony export */   loadGifImage: function() { return /* binding */ loadGifImage; }\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constants.js */ \"(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/Constants.js\");\n/* harmony import */ var _ByteStream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ByteStream.js */ \"(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/ByteStream.js\");\n\n\nconst origin = {\n    x: 0,\n    y: 0\n}, defaultFrame = 0, half = 0.5, initialTime = 0, firstIndex = 0, defaultLoopCount = 0;\nfunction parseColorTable(byteStream, count) {\n    const colors = [];\n    for(let i = 0; i < count; i++){\n        colors.push({\n            r: byteStream.data[byteStream.pos],\n            g: byteStream.data[byteStream.pos + 1],\n            b: byteStream.data[byteStream.pos + 2]\n        });\n        byteStream.pos += 3;\n    }\n    return colors;\n}\nfunction parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex) {\n    switch(byteStream.nextByte()){\n        case 249:\n            {\n                const frame = gif.frames[getFrameIndex(false)];\n                byteStream.pos++;\n                const packedByte = byteStream.nextByte();\n                frame.GCreserved = (packedByte & 0xe0) >>> 5;\n                frame.disposalMethod = (packedByte & 0x1c) >>> 2;\n                frame.userInputDelayFlag = (packedByte & 2) === 2;\n                const transparencyFlag = (packedByte & 1) === 1;\n                frame.delayTime = byteStream.nextTwoBytes() * 0xa;\n                const transparencyIndex = byteStream.nextByte();\n                if (transparencyFlag) {\n                    getTransparencyIndex(transparencyIndex);\n                }\n                byteStream.pos++;\n                break;\n            }\n        case 255:\n            {\n                byteStream.pos++;\n                const applicationExtension = {\n                    identifier: byteStream.getString(8),\n                    authenticationCode: byteStream.getString(3),\n                    data: byteStream.readSubBlocksBin()\n                };\n                gif.applicationExtensions.push(applicationExtension);\n                break;\n            }\n        case 254:\n            {\n                gif.comments.push([\n                    getFrameIndex(false),\n                    byteStream.readSubBlocks()\n                ]);\n                break;\n            }\n        case 1:\n            {\n                if (gif.globalColorTable.length === 0) {\n                    throw new EvalError(\"plain text extension without global color table\");\n                }\n                byteStream.pos++;\n                gif.frames[getFrameIndex(false)].plainTextData = {\n                    left: byteStream.nextTwoBytes(),\n                    top: byteStream.nextTwoBytes(),\n                    width: byteStream.nextTwoBytes(),\n                    height: byteStream.nextTwoBytes(),\n                    charSize: {\n                        width: byteStream.nextTwoBytes(),\n                        height: byteStream.nextTwoBytes()\n                    },\n                    foregroundColor: byteStream.nextByte(),\n                    backgroundColor: byteStream.nextByte(),\n                    text: byteStream.readSubBlocks()\n                };\n                break;\n            }\n        default:\n            byteStream.skipSubBlocks();\n            break;\n    }\n}\nasync function parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    const frame = gif.frames[getFrameIndex(true)];\n    frame.left = byteStream.nextTwoBytes();\n    frame.top = byteStream.nextTwoBytes();\n    frame.width = byteStream.nextTwoBytes();\n    frame.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), localColorTableFlag = (packedByte & 0x80) === 0x80, interlacedFlag = (packedByte & 0x40) === 0x40;\n    frame.sortFlag = (packedByte & 0x20) === 0x20;\n    frame.reserved = (packedByte & 0x18) >>> 3;\n    const localColorCount = 1 << (packedByte & 7) + 1;\n    if (localColorTableFlag) {\n        frame.localColorTable = parseColorTable(byteStream, localColorCount);\n    }\n    const getColor = (index)=>{\n        const { r, g, b } = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index];\n        if (index !== getTransparencyIndex(null)) {\n            return {\n                r,\n                g,\n                b,\n                a: 255\n            };\n        }\n        return {\n            r,\n            g,\n            b,\n            a: avgAlpha ? ~~((r + g + b) / 3) : 0\n        };\n    };\n    const image = (()=>{\n        try {\n            return new ImageData(frame.width, frame.height, {\n                colorSpace: \"srgb\"\n            });\n        } catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (image == null) {\n        throw new EvalError(\"GIF frame size is to large\");\n    }\n    const minCodeSize = byteStream.nextByte(), imageData = byteStream.readSubBlocksBin(), clearCode = 1 << minCodeSize;\n    const readBits = (pos, len)=>{\n        const bytePos = pos >>> 3, bitPos = pos & 7;\n        return (imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16) & (1 << len) - 1 << bitPos) >>> bitPos;\n    };\n    if (interlacedFlag) {\n        for(let code = 0, size = minCodeSize + 1, pos = 0, dic = [\n            [\n                0\n            ]\n        ], pass = 0; pass < 4; pass++){\n            if (_Constants_js__WEBPACK_IMPORTED_MODULE_0__.InterlaceOffsets[pass] < frame.height) {\n                let pixelPos = 0, lineIndex = 0, exit = false;\n                while(!exit){\n                    const last = code;\n                    code = readBits(pos, size);\n                    pos += size + 1;\n                    if (code === clearCode) {\n                        size = minCodeSize + 1;\n                        dic.length = clearCode + 2;\n                        for(let i = 0; i < dic.length; i++){\n                            dic[i] = i < clearCode ? [\n                                i\n                            ] : [];\n                        }\n                    } else {\n                        if (code >= dic.length) {\n                            dic.push(dic[last].concat(dic[last][0]));\n                        } else if (last !== clearCode) {\n                            dic.push(dic[last].concat(dic[code][0]));\n                        }\n                        for (const item of dic[code]){\n                            const { r, g, b, a } = getColor(item);\n                            image.data.set([\n                                r,\n                                g,\n                                b,\n                                a\n                            ], _Constants_js__WEBPACK_IMPORTED_MODULE_0__.InterlaceOffsets[pass] * frame.width + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.InterlaceSteps[pass] * lineIndex + pixelPos % (frame.width * 4));\n                            pixelPos += 4;\n                        }\n                        if (dic.length === 1 << size && size < 0xc) {\n                            size++;\n                        }\n                    }\n                    if (pixelPos === frame.width * 4 * (lineIndex + 1)) {\n                        lineIndex++;\n                        if (_Constants_js__WEBPACK_IMPORTED_MODULE_0__.InterlaceOffsets[pass] + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.InterlaceSteps[pass] * lineIndex >= frame.height) {\n                            exit = true;\n                        }\n                    }\n                }\n            }\n            progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, {\n                x: frame.left,\n                y: frame.top\n            }, {\n                width: gif.width,\n                height: gif.height\n            });\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n    } else {\n        let code = 0, size = minCodeSize + 1, pos = 0, pixelPos = -4, exit = false;\n        const dic = [\n            [\n                0\n            ]\n        ];\n        while(!exit){\n            const last = code;\n            code = readBits(pos, size);\n            pos += size;\n            if (code === clearCode) {\n                size = minCodeSize + 1;\n                dic.length = clearCode + 2;\n                for(let i = 0; i < dic.length; i++){\n                    dic[i] = i < clearCode ? [\n                        i\n                    ] : [];\n                }\n            } else {\n                if (code === clearCode + 1) {\n                    exit = true;\n                    break;\n                }\n                if (code >= dic.length) {\n                    dic.push(dic[last].concat(dic[last][0]));\n                } else if (last !== clearCode) {\n                    dic.push(dic[last].concat(dic[code][0]));\n                }\n                for (const item of dic[code]){\n                    const { r, g, b, a } = getColor(item);\n                    image.data.set([\n                        r,\n                        g,\n                        b,\n                        a\n                    ], pixelPos += 4);\n                }\n                if (dic.length >= 1 << size && size < 0xc) {\n                    size++;\n                }\n            }\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n        progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, {\n            x: frame.left,\n            y: frame.top\n        }, {\n            width: gif.width,\n            height: gif.height\n        });\n    }\n}\nasync function parseBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    switch(byteStream.nextByte()){\n        case 59:\n            return true;\n        case 44:\n            await parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\n            break;\n        case 33:\n            parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\n            break;\n        default:\n            throw new EvalError(\"undefined block found\");\n    }\n    return false;\n}\nfunction getGIFLoopAmount(gif) {\n    for (const extension of gif.applicationExtensions){\n        if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\n            continue;\n        }\n        return extension.data[1] + (extension.data[2] << 8);\n    }\n    return NaN;\n}\nasync function decodeGIF(gifURL, progressCallback, avgAlpha) {\n    if (!avgAlpha) avgAlpha = false;\n    const res = await fetch(gifURL);\n    if (!res.ok && res.status === 404) {\n        throw new EvalError(\"file not found\");\n    }\n    const buffer = await res.arrayBuffer();\n    const gif = {\n        width: 0,\n        height: 0,\n        totalTime: 0,\n        colorRes: 0,\n        pixelAspectRatio: 0,\n        frames: [],\n        sortFlag: false,\n        globalColorTable: [],\n        backgroundImage: new ImageData(1, 1, {\n            colorSpace: \"srgb\"\n        }),\n        comments: [],\n        applicationExtensions: []\n    }, byteStream = new _ByteStream_js__WEBPACK_IMPORTED_MODULE_1__.ByteStream(new Uint8ClampedArray(buffer));\n    if (byteStream.getString(6) !== \"GIF89a\") {\n        throw new Error(\"not a supported GIF file\");\n    }\n    gif.width = byteStream.nextTwoBytes();\n    gif.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), globalColorTableFlag = (packedByte & 0x80) === 0x80;\n    gif.colorRes = (packedByte & 0x70) >>> 4;\n    gif.sortFlag = (packedByte & 8) === 8;\n    const globalColorCount = 1 << (packedByte & 7) + 1, backgroundColorIndex = byteStream.nextByte();\n    gif.pixelAspectRatio = byteStream.nextByte();\n    if (gif.pixelAspectRatio !== 0) {\n        gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\n    }\n    if (globalColorTableFlag) {\n        gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\n    }\n    const backgroundImage = (()=>{\n        try {\n            return new ImageData(gif.width, gif.height, {\n                colorSpace: \"srgb\"\n            });\n        } catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (backgroundImage == null) {\n        throw new Error(\"GIF frame size is to large\");\n    }\n    const { r, g, b } = gif.globalColorTable[backgroundColorIndex];\n    backgroundImage.data.set(globalColorTableFlag ? [\n        r,\n        g,\n        b,\n        255\n    ] : [\n        0,\n        0,\n        0,\n        0\n    ]);\n    for(let i = 4; i < backgroundImage.data.length; i *= 2){\n        backgroundImage.data.copyWithin(i, 0, i);\n    }\n    gif.backgroundImage = backgroundImage;\n    let frameIndex = -1, incrementFrameIndex = true, transparencyIndex = -1;\n    const getframeIndex = (increment)=>{\n        if (increment) {\n            incrementFrameIndex = true;\n        }\n        return frameIndex;\n    };\n    const getTransparencyIndex = (newValue)=>{\n        if (newValue != null) {\n            transparencyIndex = newValue;\n        }\n        return transparencyIndex;\n    };\n    try {\n        do {\n            if (incrementFrameIndex) {\n                gif.frames.push({\n                    left: 0,\n                    top: 0,\n                    width: 0,\n                    height: 0,\n                    disposalMethod: 0,\n                    image: new ImageData(1, 1, {\n                        colorSpace: \"srgb\"\n                    }),\n                    plainTextData: null,\n                    userInputDelayFlag: false,\n                    delayTime: 0,\n                    sortFlag: false,\n                    localColorTable: [],\n                    reserved: 0,\n                    GCreserved: 0\n                });\n                frameIndex++;\n                transparencyIndex = -1;\n                incrementFrameIndex = false;\n            }\n        }while (!await parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback));\n        gif.frames.length--;\n        for (const frame of gif.frames){\n            if (frame.userInputDelayFlag && frame.delayTime === 0) {\n                gif.totalTime = Infinity;\n                break;\n            }\n            gif.totalTime += frame.delayTime;\n        }\n        return gif;\n    } catch (error) {\n        if (error instanceof EvalError) {\n            throw new Error(\"error while parsing frame \".concat(frameIndex, ' \"').concat(error.message, '\"'));\n        }\n        throw error;\n    }\n}\nfunction drawGif(data) {\n    const { context, radius, particle, delta } = data, image = particle.image;\n    if (!(image === null || image === void 0 ? void 0 : image.gifData) || !image.gif) {\n        return;\n    }\n    const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height), offscreenContext = offscreenCanvas.getContext(\"2d\");\n    if (!offscreenContext) {\n        throw new Error(\"could not create offscreen canvas context\");\n    }\n    offscreenContext.imageSmoothingQuality = \"low\";\n    offscreenContext.imageSmoothingEnabled = false;\n    offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n    if (particle.gifLoopCount === undefined) {\n        var _image_gifLoopCount;\n        particle.gifLoopCount = (_image_gifLoopCount = image.gifLoopCount) !== null && _image_gifLoopCount !== void 0 ? _image_gifLoopCount : defaultLoopCount;\n    }\n    var _particle_gifFrame;\n    let frameIndex = (_particle_gifFrame = particle.gifFrame) !== null && _particle_gifFrame !== void 0 ? _particle_gifFrame : defaultFrame;\n    const pos = {\n        x: -image.gifData.width * half,\n        y: -image.gifData.height * half\n    }, frame = image.gifData.frames[frameIndex];\n    if (particle.gifTime === undefined) {\n        particle.gifTime = initialTime;\n    }\n    if (!frame.bitmap) {\n        return;\n    }\n    context.scale(radius / image.gifData.width, radius / image.gifData.height);\n    switch(frame.disposalMethod){\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 0:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            break;\n        case 1:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            break;\n        case 2:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            if (!image.gifData.globalColorTable.length) {\n                offscreenContext.putImageData(image.gifData.frames[firstIndex].image, pos.x + frame.left, pos.y + frame.top);\n            } else {\n                offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n            }\n            break;\n        case 3:\n            {\n                const previousImageData = offscreenContext.getImageData(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                context.drawImage(offscreenCanvas, pos.x, pos.y);\n                offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.putImageData(previousImageData, origin.x, origin.y);\n            }\n            break;\n    }\n    particle.gifTime += delta.value;\n    if (particle.gifTime > frame.delayTime) {\n        particle.gifTime -= frame.delayTime;\n        if (++frameIndex >= image.gifData.frames.length) {\n            if (--particle.gifLoopCount <= defaultLoopCount) {\n                return;\n            }\n            frameIndex = firstIndex;\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n        }\n        particle.gifFrame = frameIndex;\n    }\n    context.scale(image.gifData.width / radius, image.gifData.height / radius);\n}\nasync function loadGifImage(image) {\n    if (image.type !== \"gif\") {\n        const { loadImage } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../Utils.js */ \"(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/Utils.js\"));\n        await loadImage(image);\n        return;\n    }\n    image.loading = true;\n    try {\n        image.gifData = await decodeGIF(image.source);\n        var _getGIFLoopAmount;\n        image.gifLoopCount = (_getGIFLoopAmount = getGIFLoopAmount(image.gifData)) !== null && _getGIFLoopAmount !== void 0 ? _getGIFLoopAmount : defaultLoopCount;\n        if (!image.gifLoopCount) {\n            image.gifLoopCount = Infinity;\n        }\n    } catch (e) {\n        image.error = true;\n    }\n    image.loading = false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHNwYXJ0aWNsZXMvc2hhcGUtaW1hZ2UvYnJvd3Nlci9HaWZVdGlscy9VdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0U7QUFDckI7QUFDN0MsTUFBTUcsU0FBUztJQUNYQyxHQUFHO0lBQ0hDLEdBQUc7QUFDUCxHQUFHQyxlQUFlLEdBQUdDLE9BQU8sS0FBS0MsY0FBYyxHQUFHQyxhQUFhLEdBQUdDLG1CQUFtQjtBQUNyRixTQUFTQyxnQkFBZ0JDLFVBQVUsRUFBRUMsS0FBSztJQUN0QyxNQUFNQyxTQUFTLEVBQUU7SUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLE9BQU9FLElBQUs7UUFDNUJELE9BQU9FLElBQUksQ0FBQztZQUNSQyxHQUFHTCxXQUFXTSxJQUFJLENBQUNOLFdBQVdPLEdBQUcsQ0FBQztZQUNsQ0MsR0FBR1IsV0FBV00sSUFBSSxDQUFDTixXQUFXTyxHQUFHLEdBQUcsRUFBRTtZQUN0Q0UsR0FBR1QsV0FBV00sSUFBSSxDQUFDTixXQUFXTyxHQUFHLEdBQUcsRUFBRTtRQUMxQztRQUNBUCxXQUFXTyxHQUFHLElBQUk7SUFDdEI7SUFDQSxPQUFPTDtBQUNYO0FBQ0EsU0FBU1Esb0JBQW9CVixVQUFVLEVBQUVXLEdBQUcsRUFBRUMsYUFBYSxFQUFFQyxvQkFBb0I7SUFDN0UsT0FBUWIsV0FBV2MsUUFBUTtRQUN2QixLQUFLO1lBQUs7Z0JBQ04sTUFBTUMsUUFBUUosSUFBSUssTUFBTSxDQUFDSixjQUFjLE9BQU87Z0JBQzlDWixXQUFXTyxHQUFHO2dCQUNkLE1BQU1VLGFBQWFqQixXQUFXYyxRQUFRO2dCQUN0Q0MsTUFBTUcsVUFBVSxHQUFHLENBQUNELGFBQWEsSUFBRyxNQUFPO2dCQUMzQ0YsTUFBTUksY0FBYyxHQUFHLENBQUNGLGFBQWEsSUFBRyxNQUFPO2dCQUMvQ0YsTUFBTUssa0JBQWtCLEdBQUcsQ0FBQ0gsYUFBYSxPQUFPO2dCQUNoRCxNQUFN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SyxDQUFDeEUsTUFBTTRELE9BQU8sQ0FBQy9FLEtBQUssR0FBRzRFLFFBQVF6RCxNQUFNNEQsT0FBTyxDQUFDOUUsTUFBTSxHQUFHMkU7QUFDdkU7QUFDTyxlQUFlcUIsYUFBYTlFLEtBQUs7SUFDcEMsSUFBSUEsTUFBTStFLElBQUksS0FBSyxPQUFPO1FBQ3RCLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUcsTUFBTSx1TEFBcUI7UUFDakQsTUFBTUEsVUFBVWhGO1FBQ2hCO0lBQ0o7SUFDQUEsTUFBTWlGLE9BQU8sR0FBRztJQUNoQixJQUFJO1FBQ0FqRixNQUFNNEQsT0FBTyxHQUFHLE1BQU05QixVQUFVOUIsTUFBTWtGLE1BQU07WUFDdkJ2RDtRQUFyQjNCLE1BQU1vRSxZQUFZLEdBQUd6QyxDQUFBQSxvQkFBQUEsaUJBQWlCM0IsTUFBTTRELE9BQU8sZUFBOUJqQywrQkFBQUEsb0JBQW1DdkY7UUFDeEQsSUFBSSxDQUFDNEQsTUFBTW9FLFlBQVksRUFBRTtZQUNyQnBFLE1BQU1vRSxZQUFZLEdBQUdmO1FBQ3pCO0lBQ0osRUFDQSxVQUFNO1FBQ0ZyRCxNQUFNRyxLQUFLLEdBQUc7SUFDbEI7SUFDQUgsTUFBTWlGLE9BQU8sR0FBRztBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRzcGFydGljbGVzL3NoYXBlLWltYWdlL2Jyb3dzZXIvR2lmVXRpbHMvVXRpbHMuanM/YThjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmxhY2VPZmZzZXRzLCBJbnRlcmxhY2VTdGVwcyB9IGZyb20gXCIuL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgQnl0ZVN0cmVhbSB9IGZyb20gXCIuL0J5dGVTdHJlYW0uanNcIjtcbmNvbnN0IG9yaWdpbiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG59LCBkZWZhdWx0RnJhbWUgPSAwLCBoYWxmID0gMC41LCBpbml0aWFsVGltZSA9IDAsIGZpcnN0SW5kZXggPSAwLCBkZWZhdWx0TG9vcENvdW50ID0gMDtcbmZ1bmN0aW9uIHBhcnNlQ29sb3JUYWJsZShieXRlU3RyZWFtLCBjb3VudCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb2xvcnMucHVzaCh7XG4gICAgICAgICAgICByOiBieXRlU3RyZWFtLmRhdGFbYnl0ZVN0cmVhbS5wb3NdLFxuICAgICAgICAgICAgZzogYnl0ZVN0cmVhbS5kYXRhW2J5dGVTdHJlYW0ucG9zICsgMV0sXG4gICAgICAgICAgICBiOiBieXRlU3RyZWFtLmRhdGFbYnl0ZVN0cmVhbS5wb3MgKyAyXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJ5dGVTdHJlYW0ucG9zICs9IDM7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcnM7XG59XG5mdW5jdGlvbiBwYXJzZUV4dGVuc2lvbkJsb2NrKGJ5dGVTdHJlYW0sIGdpZiwgZ2V0RnJhbWVJbmRleCwgZ2V0VHJhbnNwYXJlbmN5SW5kZXgpIHtcbiAgICBzd2l0Y2ggKGJ5dGVTdHJlYW0ubmV4dEJ5dGUoKSkge1xuICAgICAgICBjYXNlIDI0OToge1xuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBnaWYuZnJhbWVzW2dldEZyYW1lSW5kZXgoZmFsc2UpXTtcbiAgICAgICAgICAgIGJ5dGVTdHJlYW0ucG9zKys7XG4gICAgICAgICAgICBjb25zdCBwYWNrZWRCeXRlID0gYnl0ZVN0cmVhbS5uZXh0Qnl0ZSgpO1xuICAgICAgICAgICAgZnJhbWUuR0NyZXNlcnZlZCA9IChwYWNrZWRCeXRlICYgMHhlMCkgPj4+IDU7XG4gICAgICAgICAgICBmcmFtZS5kaXNwb3NhbE1ldGhvZCA9IChwYWNrZWRCeXRlICYgMHgxYykgPj4+IDI7XG4gICAgICAgICAgICBmcmFtZS51c2VySW5wdXREZWxheUZsYWcgPSAocGFja2VkQnl0ZSAmIDIpID09PSAyO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwYXJlbmN5RmxhZyA9IChwYWNrZWRCeXRlICYgMSkgPT09IDE7XG4gICAgICAgICAgICBmcmFtZS5kZWxheVRpbWUgPSBieXRlU3RyZWFtLm5leHRUd29CeXRlcygpICogMHhhO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwYXJlbmN5SW5kZXggPSBieXRlU3RyZWFtLm5leHRCeXRlKCk7XG4gICAgICAgICAgICBpZiAodHJhbnNwYXJlbmN5RmxhZykge1xuICAgICAgICAgICAgICAgIGdldFRyYW5zcGFyZW5jeUluZGV4KHRyYW5zcGFyZW5jeUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVTdHJlYW0ucG9zKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI1NToge1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS5wb3MrKztcbiAgICAgICAgICAgIGNvbnN0IGFwcGxpY2F0aW9uRXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGJ5dGVTdHJlYW0uZ2V0U3RyaW5nKDgpLFxuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uQ29kZTogYnl0ZVN0cmVhbS5nZXRTdHJpbmcoMyksXG4gICAgICAgICAgICAgICAgZGF0YTogYnl0ZVN0cmVhbS5yZWFkU3ViQmxvY2tzQmluKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2lmLmFwcGxpY2F0aW9uRXh0ZW5zaW9ucy5wdXNoKGFwcGxpY2F0aW9uRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjU0OiB7XG4gICAgICAgICAgICBnaWYuY29tbWVudHMucHVzaChbZ2V0RnJhbWVJbmRleChmYWxzZSksIGJ5dGVTdHJlYW0ucmVhZFN1YkJsb2NrcygpXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIGlmIChnaWYuZ2xvYmFsQ29sb3JUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZhbEVycm9yKFwicGxhaW4gdGV4dCBleHRlbnNpb24gd2l0aG91dCBnbG9iYWwgY29sb3IgdGFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlU3RyZWFtLnBvcysrO1xuICAgICAgICAgICAgZ2lmLmZyYW1lc1tnZXRGcmFtZUluZGV4KGZhbHNlKV0ucGxhaW5UZXh0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBieXRlU3RyZWFtLm5leHRUd29CeXRlcygpLFxuICAgICAgICAgICAgICAgIHRvcDogYnl0ZVN0cmVhbS5uZXh0VHdvQnl0ZXMoKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogYnl0ZVN0cmVhbS5uZXh0VHdvQnl0ZXMoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJ5dGVTdHJlYW0ubmV4dFR3b0J5dGVzKCksXG4gICAgICAgICAgICAgICAgY2hhclNpemU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJ5dGVTdHJlYW0ubmV4dFR3b0J5dGVzKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYnl0ZVN0cmVhbS5uZXh0VHdvQnl0ZXMoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcmVncm91bmRDb2xvcjogYnl0ZVN0cmVhbS5uZXh0Qnl0ZSgpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYnl0ZVN0cmVhbS5uZXh0Qnl0ZSgpLFxuICAgICAgICAgICAgICAgIHRleHQ6IGJ5dGVTdHJlYW0ucmVhZFN1YkJsb2NrcygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNraXBTdWJCbG9ja3MoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlSW1hZ2VCbG9jayhieXRlU3RyZWFtLCBnaWYsIGF2Z0FscGhhLCBnZXRGcmFtZUluZGV4LCBnZXRUcmFuc3BhcmVuY3lJbmRleCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIGNvbnN0IGZyYW1lID0gZ2lmLmZyYW1lc1tnZXRGcmFtZUluZGV4KHRydWUpXTtcbiAgICBmcmFtZS5sZWZ0ID0gYnl0ZVN0cmVhbS5uZXh0VHdvQnl0ZXMoKTtcbiAgICBmcmFtZS50b3AgPSBieXRlU3RyZWFtLm5leHRUd29CeXRlcygpO1xuICAgIGZyYW1lLndpZHRoID0gYnl0ZVN0cmVhbS5uZXh0VHdvQnl0ZXMoKTtcbiAgICBmcmFtZS5oZWlnaHQgPSBieXRlU3RyZWFtLm5leHRUd29CeXRlcygpO1xuICAgIGNvbnN0IHBhY2tlZEJ5dGUgPSBieXRlU3RyZWFtLm5leHRCeXRlKCksIGxvY2FsQ29sb3JUYWJsZUZsYWcgPSAocGFja2VkQnl0ZSAmIDB4ODApID09PSAweDgwLCBpbnRlcmxhY2VkRmxhZyA9IChwYWNrZWRCeXRlICYgMHg0MCkgPT09IDB4NDA7XG4gICAgZnJhbWUuc29ydEZsYWcgPSAocGFja2VkQnl0ZSAmIDB4MjApID09PSAweDIwO1xuICAgIGZyYW1lLnJlc2VydmVkID0gKHBhY2tlZEJ5dGUgJiAweDE4KSA+Pj4gMztcbiAgICBjb25zdCBsb2NhbENvbG9yQ291bnQgPSAxIDw8ICgocGFja2VkQnl0ZSAmIDcpICsgMSk7XG4gICAgaWYgKGxvY2FsQ29sb3JUYWJsZUZsYWcpIHtcbiAgICAgICAgZnJhbWUubG9jYWxDb2xvclRhYmxlID0gcGFyc2VDb2xvclRhYmxlKGJ5dGVTdHJlYW0sIGxvY2FsQ29sb3JDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGdldENvbG9yID0gKGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgciwgZywgYiB9ID0gKGxvY2FsQ29sb3JUYWJsZUZsYWcgPyBmcmFtZS5sb2NhbENvbG9yVGFibGUgOiBnaWYuZ2xvYmFsQ29sb3JUYWJsZSlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXggIT09IGdldFRyYW5zcGFyZW5jeUluZGV4KG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByLCBnLCBiLCBhOiAyNTUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByLCBnLCBiLCBhOiBhdmdBbHBoYSA/IH5+KChyICsgZyArIGIpIC8gMykgOiAwIH07XG4gICAgfTtcbiAgICBjb25zdCBpbWFnZSA9ICgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlRGF0YShmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0LCB7IGNvbG9yU3BhY2U6IFwic3JnYlwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiSW5kZXhTaXplRXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGlmIChpbWFnZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFdmFsRXJyb3IoXCJHSUYgZnJhbWUgc2l6ZSBpcyB0byBsYXJnZVwiKTtcbiAgICB9XG4gICAgY29uc3QgbWluQ29kZVNpemUgPSBieXRlU3RyZWFtLm5leHRCeXRlKCksIGltYWdlRGF0YSA9IGJ5dGVTdHJlYW0ucmVhZFN1YkJsb2Nrc0JpbigpLCBjbGVhckNvZGUgPSAxIDw8IG1pbkNvZGVTaXplO1xuICAgIGNvbnN0IHJlYWRCaXRzID0gKHBvcywgbGVuKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ5dGVQb3MgPSBwb3MgPj4+IDMsIGJpdFBvcyA9IHBvcyAmIDc7XG4gICAgICAgIHJldHVybiAoKChpbWFnZURhdGFbYnl0ZVBvc10gKyAoaW1hZ2VEYXRhW2J5dGVQb3MgKyAxXSA8PCA4KSArIChpbWFnZURhdGFbYnl0ZVBvcyArIDJdIDw8IDE2KSkgJlxuICAgICAgICAgICAgKCgoMSA8PCBsZW4pIC0gMSkgPDwgYml0UG9zKSkgPj4+XG4gICAgICAgICAgICBiaXRQb3MpO1xuICAgIH07XG4gICAgaWYgKGludGVybGFjZWRGbGFnKSB7XG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwLCBzaXplID0gbWluQ29kZVNpemUgKyAxLCBwb3MgPSAwLCBkaWMgPSBbWzBdXSwgcGFzcyA9IDA7IHBhc3MgPCA0OyBwYXNzKyspIHtcbiAgICAgICAgICAgIGlmIChJbnRlcmxhY2VPZmZzZXRzW3Bhc3NdIDwgZnJhbWUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpeGVsUG9zID0gMCwgbGluZUluZGV4ID0gMCwgZXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlICghZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IHJlYWRCaXRzKHBvcywgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBzaXplICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IGNsZWFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IG1pbkNvZGVTaXplICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYy5sZW5ndGggPSBjbGVhckNvZGUgKyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWNbaV0gPSBpIDwgY2xlYXJDb2RlID8gW2ldIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSBkaWMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGljLnB1c2goZGljW2xhc3RdLmNvbmNhdChkaWNbbGFzdF1bMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3QgIT09IGNsZWFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYy5wdXNoKGRpY1tsYXN0XS5jb25jYXQoZGljW2NvZGVdWzBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGljW2NvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByLCBnLCBiLCBhIH0gPSBnZXRDb2xvcihpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5kYXRhLnNldChbciwgZywgYiwgYV0sIEludGVybGFjZU9mZnNldHNbcGFzc10gKiBmcmFtZS53aWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEludGVybGFjZVN0ZXBzW3Bhc3NdICogbGluZUluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBpeGVsUG9zICUgKGZyYW1lLndpZHRoICogNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFBvcyArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpYy5sZW5ndGggPT09IDEgPDwgc2l6ZSAmJiBzaXplIDwgMHhjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbFBvcyA9PT0gZnJhbWUud2lkdGggKiA0ICogKGxpbmVJbmRleCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJbnRlcmxhY2VPZmZzZXRzW3Bhc3NdICsgSW50ZXJsYWNlU3RlcHNbcGFzc10gKiBsaW5lSW5kZXggPj0gZnJhbWUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrPy4oYnl0ZVN0cmVhbS5wb3MgLyAoYnl0ZVN0cmVhbS5kYXRhLmxlbmd0aCAtIDEpLCBnZXRGcmFtZUluZGV4KGZhbHNlKSArIDEsIGltYWdlLCB7IHg6IGZyYW1lLmxlZnQsIHk6IGZyYW1lLnRvcCB9LCB7IHdpZHRoOiBnaWYud2lkdGgsIGhlaWdodDogZ2lmLmhlaWdodCB9KTtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZS5pbWFnZSA9IGltYWdlO1xuICAgICAgICBmcmFtZS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY29kZSA9IDAsIHNpemUgPSBtaW5Db2RlU2l6ZSArIDEsIHBvcyA9IDAsIHBpeGVsUG9zID0gLTQsIGV4aXQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZGljID0gW1swXV07XG4gICAgICAgIHdoaWxlICghZXhpdCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IGNvZGU7XG4gICAgICAgICAgICBjb2RlID0gcmVhZEJpdHMocG9zLCBzaXplKTtcbiAgICAgICAgICAgIHBvcyArPSBzaXplO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGNsZWFyQ29kZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBtaW5Db2RlU2l6ZSArIDE7XG4gICAgICAgICAgICAgICAgZGljLmxlbmd0aCA9IGNsZWFyQ29kZSArIDI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGljW2ldID0gaSA8IGNsZWFyQ29kZSA/IFtpXSA6IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBjbGVhckNvZGUgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gZGljLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkaWMucHVzaChkaWNbbGFzdF0uY29uY2F0KGRpY1tsYXN0XVswXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0ICE9PSBjbGVhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGljLnB1c2goZGljW2xhc3RdLmNvbmNhdChkaWNbY29kZV1bMF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRpY1tjb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHIsIGcsIGIsIGEgfSA9IGdldENvbG9yKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5kYXRhLnNldChbciwgZywgYiwgYV0sIChwaXhlbFBvcyArPSA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaWMubGVuZ3RoID49IDEgPDwgc2l6ZSAmJiBzaXplIDwgMHhjKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgZnJhbWUuYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UpO1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrPy4oKGJ5dGVTdHJlYW0ucG9zICsgMSkgLyBieXRlU3RyZWFtLmRhdGEubGVuZ3RoLCBnZXRGcmFtZUluZGV4KGZhbHNlKSArIDEsIGZyYW1lLmltYWdlLCB7IHg6IGZyYW1lLmxlZnQsIHk6IGZyYW1lLnRvcCB9LCB7IHdpZHRoOiBnaWYud2lkdGgsIGhlaWdodDogZ2lmLmhlaWdodCB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUJsb2NrKGJ5dGVTdHJlYW0sIGdpZiwgYXZnQWxwaGEsIGdldEZyYW1lSW5kZXgsIGdldFRyYW5zcGFyZW5jeUluZGV4LCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgc3dpdGNoIChieXRlU3RyZWFtLm5leHRCeXRlKCkpIHtcbiAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgYXdhaXQgcGFyc2VJbWFnZUJsb2NrKGJ5dGVTdHJlYW0sIGdpZiwgYXZnQWxwaGEsIGdldEZyYW1lSW5kZXgsIGdldFRyYW5zcGFyZW5jeUluZGV4LCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgcGFyc2VFeHRlbnNpb25CbG9jayhieXRlU3RyZWFtLCBnaWYsIGdldEZyYW1lSW5kZXgsIGdldFRyYW5zcGFyZW5jeUluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2YWxFcnJvcihcInVuZGVmaW5lZCBibG9jayBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEdJRkxvb3BBbW91bnQoZ2lmKSB7XG4gICAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgZ2lmLmFwcGxpY2F0aW9uRXh0ZW5zaW9ucykge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLmlkZW50aWZpZXIgKyBleHRlbnNpb24uYXV0aGVudGljYXRpb25Db2RlICE9PSBcIk5FVFNDQVBFMi4wXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnNpb24uZGF0YVsxXSArIChleHRlbnNpb24uZGF0YVsyXSA8PCA4KTtcbiAgICB9XG4gICAgcmV0dXJuIE5hTjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNvZGVHSUYoZ2lmVVJMLCBwcm9ncmVzc0NhbGxiYWNrLCBhdmdBbHBoYSkge1xuICAgIGlmICghYXZnQWxwaGEpXG4gICAgICAgIGF2Z0FscGhhID0gZmFsc2U7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goZ2lmVVJMKTtcbiAgICBpZiAoIXJlcy5vayAmJiByZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV2YWxFcnJvcihcImZpbGUgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBnaWYgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvdGFsVGltZTogMCxcbiAgICAgICAgY29sb3JSZXM6IDAsXG4gICAgICAgIHBpeGVsQXNwZWN0UmF0aW86IDAsXG4gICAgICAgIGZyYW1lczogW10sXG4gICAgICAgIHNvcnRGbGFnOiBmYWxzZSxcbiAgICAgICAgZ2xvYmFsQ29sb3JUYWJsZTogW10sXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogbmV3IEltYWdlRGF0YSgxLCAxLCB7IGNvbG9yU3BhY2U6IFwic3JnYlwiIH0pLFxuICAgICAgICBjb21tZW50czogW10sXG4gICAgICAgIGFwcGxpY2F0aW9uRXh0ZW5zaW9uczogW10sXG4gICAgfSwgYnl0ZVN0cmVhbSA9IG5ldyBCeXRlU3RyZWFtKG5ldyBVaW50OENsYW1wZWRBcnJheShidWZmZXIpKTtcbiAgICBpZiAoYnl0ZVN0cmVhbS5nZXRTdHJpbmcoNikgIT09IFwiR0lGODlhXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGEgc3VwcG9ydGVkIEdJRiBmaWxlXCIpO1xuICAgIH1cbiAgICBnaWYud2lkdGggPSBieXRlU3RyZWFtLm5leHRUd29CeXRlcygpO1xuICAgIGdpZi5oZWlnaHQgPSBieXRlU3RyZWFtLm5leHRUd29CeXRlcygpO1xuICAgIGNvbnN0IHBhY2tlZEJ5dGUgPSBieXRlU3RyZWFtLm5leHRCeXRlKCksIGdsb2JhbENvbG9yVGFibGVGbGFnID0gKHBhY2tlZEJ5dGUgJiAweDgwKSA9PT0gMHg4MDtcbiAgICBnaWYuY29sb3JSZXMgPSAocGFja2VkQnl0ZSAmIDB4NzApID4+PiA0O1xuICAgIGdpZi5zb3J0RmxhZyA9IChwYWNrZWRCeXRlICYgOCkgPT09IDg7XG4gICAgY29uc3QgZ2xvYmFsQ29sb3JDb3VudCA9IDEgPDwgKChwYWNrZWRCeXRlICYgNykgKyAxKSwgYmFja2dyb3VuZENvbG9ySW5kZXggPSBieXRlU3RyZWFtLm5leHRCeXRlKCk7XG4gICAgZ2lmLnBpeGVsQXNwZWN0UmF0aW8gPSBieXRlU3RyZWFtLm5leHRCeXRlKCk7XG4gICAgaWYgKGdpZi5waXhlbEFzcGVjdFJhdGlvICE9PSAwKSB7XG4gICAgICAgIGdpZi5waXhlbEFzcGVjdFJhdGlvID0gKGdpZi5waXhlbEFzcGVjdFJhdGlvICsgMHhmKSAvIDB4NDA7XG4gICAgfVxuICAgIGlmIChnbG9iYWxDb2xvclRhYmxlRmxhZykge1xuICAgICAgICBnaWYuZ2xvYmFsQ29sb3JUYWJsZSA9IHBhcnNlQ29sb3JUYWJsZShieXRlU3RyZWFtLCBnbG9iYWxDb2xvckNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgYmFja2dyb3VuZEltYWdlID0gKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VEYXRhKGdpZi53aWR0aCwgZ2lmLmhlaWdodCwgeyBjb2xvclNwYWNlOiBcInNyZ2JcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkluZGV4U2l6ZUVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICBpZiAoYmFja2dyb3VuZEltYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR0lGIGZyYW1lIHNpemUgaXMgdG8gbGFyZ2VcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgciwgZywgYiB9ID0gZ2lmLmdsb2JhbENvbG9yVGFibGVbYmFja2dyb3VuZENvbG9ySW5kZXhdO1xuICAgIGJhY2tncm91bmRJbWFnZS5kYXRhLnNldChnbG9iYWxDb2xvclRhYmxlRmxhZyA/IFtyLCBnLCBiLCAyNTVdIDogWzAsIDAsIDAsIDBdKTtcbiAgICBmb3IgKGxldCBpID0gNDsgaSA8IGJhY2tncm91bmRJbWFnZS5kYXRhLmxlbmd0aDsgaSAqPSAyKSB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZS5kYXRhLmNvcHlXaXRoaW4oaSwgMCwgaSk7XG4gICAgfVxuICAgIGdpZi5iYWNrZ3JvdW5kSW1hZ2UgPSBiYWNrZ3JvdW5kSW1hZ2U7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAtMSwgaW5jcmVtZW50RnJhbWVJbmRleCA9IHRydWUsIHRyYW5zcGFyZW5jeUluZGV4ID0gLTE7XG4gICAgY29uc3QgZ2V0ZnJhbWVJbmRleCA9IChpbmNyZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKGluY3JlbWVudCkge1xuICAgICAgICAgICAgaW5jcmVtZW50RnJhbWVJbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYW1lSW5kZXg7XG4gICAgfTtcbiAgICBjb25zdCBnZXRUcmFuc3BhcmVuY3lJbmRleCA9IChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAobmV3VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNwYXJlbmN5SW5kZXggPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNwYXJlbmN5SW5kZXg7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50RnJhbWVJbmRleCkge1xuICAgICAgICAgICAgICAgIGdpZi5mcmFtZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWxNZXRob2Q6IDAsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBuZXcgSW1hZ2VEYXRhKDEsIDEsIHsgY29sb3JTcGFjZTogXCJzcmdiXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIHBsYWluVGV4dERhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJbnB1dERlbGF5RmxhZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5VGltZTogMCxcbiAgICAgICAgICAgICAgICAgICAgc29ydEZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbENvbG9yVGFibGU6IFtdLFxuICAgICAgICAgICAgICAgICAgICByZXNlcnZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgR0NyZXNlcnZlZDogMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbmN5SW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRGcmFtZUluZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCEoYXdhaXQgcGFyc2VCbG9jayhieXRlU3RyZWFtLCBnaWYsIGF2Z0FscGhhLCBnZXRmcmFtZUluZGV4LCBnZXRUcmFuc3BhcmVuY3lJbmRleCwgcHJvZ3Jlc3NDYWxsYmFjaykpKTtcbiAgICAgICAgZ2lmLmZyYW1lcy5sZW5ndGgtLTtcbiAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBnaWYuZnJhbWVzKSB7XG4gICAgICAgICAgICBpZiAoZnJhbWUudXNlcklucHV0RGVsYXlGbGFnICYmIGZyYW1lLmRlbGF5VGltZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGdpZi50b3RhbFRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdpZi50b3RhbFRpbWUgKz0gZnJhbWUuZGVsYXlUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnaWY7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFdmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3Igd2hpbGUgcGFyc2luZyBmcmFtZSAke2ZyYW1lSW5kZXh9IFwiJHtlcnJvci5tZXNzYWdlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdHaWYoZGF0YSkge1xuICAgIGNvbnN0IHsgY29udGV4dCwgcmFkaXVzLCBwYXJ0aWNsZSwgZGVsdGEgfSA9IGRhdGEsIGltYWdlID0gcGFydGljbGUuaW1hZ2U7XG4gICAgaWYgKCFpbWFnZT8uZ2lmRGF0YSB8fCAhaW1hZ2UuZ2lmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2NyZWVuQ2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhpbWFnZS5naWZEYXRhLndpZHRoLCBpbWFnZS5naWZEYXRhLmhlaWdodCksIG9mZnNjcmVlbkNvbnRleHQgPSBvZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghb2Zmc2NyZWVuQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgY3JlYXRlIG9mZnNjcmVlbiBjYW52YXMgY29udGV4dFwiKTtcbiAgICB9XG4gICAgb2Zmc2NyZWVuQ29udGV4dC5pbWFnZVNtb290aGluZ1F1YWxpdHkgPSBcImxvd1wiO1xuICAgIG9mZnNjcmVlbkNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgb2Zmc2NyZWVuQ29udGV4dC5jbGVhclJlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBvZmZzY3JlZW5DYW52YXMud2lkdGgsIG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQpO1xuICAgIGlmIChwYXJ0aWNsZS5naWZMb29wQ291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0aWNsZS5naWZMb29wQ291bnQgPSBpbWFnZS5naWZMb29wQ291bnQgPz8gZGVmYXVsdExvb3BDb3VudDtcbiAgICB9XG4gICAgbGV0IGZyYW1lSW5kZXggPSBwYXJ0aWNsZS5naWZGcmFtZSA/PyBkZWZhdWx0RnJhbWU7XG4gICAgY29uc3QgcG9zID0geyB4OiAtaW1hZ2UuZ2lmRGF0YS53aWR0aCAqIGhhbGYsIHk6IC1pbWFnZS5naWZEYXRhLmhlaWdodCAqIGhhbGYgfSwgZnJhbWUgPSBpbWFnZS5naWZEYXRhLmZyYW1lc1tmcmFtZUluZGV4XTtcbiAgICBpZiAocGFydGljbGUuZ2lmVGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnRpY2xlLmdpZlRpbWUgPSBpbml0aWFsVGltZTtcbiAgICB9XG4gICAgaWYgKCFmcmFtZS5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnNjYWxlKHJhZGl1cyAvIGltYWdlLmdpZkRhdGEud2lkdGgsIHJhZGl1cyAvIGltYWdlLmdpZkRhdGEuaGVpZ2h0KTtcbiAgICBzd2l0Y2ggKGZyYW1lLmRpc3Bvc2FsTWV0aG9kKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGV4dC5kcmF3SW1hZ2UoZnJhbWUuYml0bWFwLCBmcmFtZS5sZWZ0LCBmcmFtZS50b3ApO1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2Uob2Zmc2NyZWVuQ2FudmFzLCBwb3MueCwgcG9zLnkpO1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGV4dC5jbGVhclJlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBvZmZzY3JlZW5DYW52YXMud2lkdGgsIG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIG9mZnNjcmVlbkNvbnRleHQuZHJhd0ltYWdlKGZyYW1lLmJpdG1hcCwgZnJhbWUubGVmdCwgZnJhbWUudG9wKTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG9mZnNjcmVlbkNhbnZhcywgcG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBvZmZzY3JlZW5Db250ZXh0LmRyYXdJbWFnZShmcmFtZS5iaXRtYXAsIGZyYW1lLmxlZnQsIGZyYW1lLnRvcCk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShvZmZzY3JlZW5DYW52YXMsIHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICBvZmZzY3JlZW5Db250ZXh0LmNsZWFyUmVjdChvcmlnaW4ueCwgb3JpZ2luLnksIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBpZiAoIWltYWdlLmdpZkRhdGEuZ2xvYmFsQ29sb3JUYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvZmZzY3JlZW5Db250ZXh0LnB1dEltYWdlRGF0YShpbWFnZS5naWZEYXRhLmZyYW1lc1tmaXJzdEluZGV4XS5pbWFnZSwgcG9zLnggKyBmcmFtZS5sZWZ0LCBwb3MueSArIGZyYW1lLnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzY3JlZW5Db250ZXh0LnB1dEltYWdlRGF0YShpbWFnZS5naWZEYXRhLmJhY2tncm91bmRJbWFnZSwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbWFnZURhdGEgPSBvZmZzY3JlZW5Db250ZXh0LmdldEltYWdlRGF0YShvcmlnaW4ueCwgb3JpZ2luLnksIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGV4dC5kcmF3SW1hZ2UoZnJhbWUuYml0bWFwLCBmcmFtZS5sZWZ0LCBmcmFtZS50b3ApO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG9mZnNjcmVlbkNhbnZhcywgcG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgICAgICBvZmZzY3JlZW5Db250ZXh0LmNsZWFyUmVjdChvcmlnaW4ueCwgb3JpZ2luLnksIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGV4dC5wdXRJbWFnZURhdGEocHJldmlvdXNJbWFnZURhdGEsIG9yaWdpbi54LCBvcmlnaW4ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcGFydGljbGUuZ2lmVGltZSArPSBkZWx0YS52YWx1ZTtcbiAgICBpZiAocGFydGljbGUuZ2lmVGltZSA+IGZyYW1lLmRlbGF5VGltZSkge1xuICAgICAgICBwYXJ0aWNsZS5naWZUaW1lIC09IGZyYW1lLmRlbGF5VGltZTtcbiAgICAgICAgaWYgKCsrZnJhbWVJbmRleCA+PSBpbWFnZS5naWZEYXRhLmZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgtLXBhcnRpY2xlLmdpZkxvb3BDb3VudCA8PSBkZWZhdWx0TG9vcENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWVJbmRleCA9IGZpcnN0SW5kZXg7XG4gICAgICAgICAgICBvZmZzY3JlZW5Db250ZXh0LmNsZWFyUmVjdChvcmlnaW4ueCwgb3JpZ2luLnksIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydGljbGUuZ2lmRnJhbWUgPSBmcmFtZUluZGV4O1xuICAgIH1cbiAgICBjb250ZXh0LnNjYWxlKGltYWdlLmdpZkRhdGEud2lkdGggLyByYWRpdXMsIGltYWdlLmdpZkRhdGEuaGVpZ2h0IC8gcmFkaXVzKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2lmSW1hZ2UoaW1hZ2UpIHtcbiAgICBpZiAoaW1hZ2UudHlwZSAhPT0gXCJnaWZcIikge1xuICAgICAgICBjb25zdCB7IGxvYWRJbWFnZSB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vVXRpbHMuanNcIik7XG4gICAgICAgIGF3YWl0IGxvYWRJbWFnZShpbWFnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1hZ2UubG9hZGluZyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgaW1hZ2UuZ2lmRGF0YSA9IGF3YWl0IGRlY29kZUdJRihpbWFnZS5zb3VyY2UpO1xuICAgICAgICBpbWFnZS5naWZMb29wQ291bnQgPSBnZXRHSUZMb29wQW1vdW50KGltYWdlLmdpZkRhdGEpID8/IGRlZmF1bHRMb29wQ291bnQ7XG4gICAgICAgIGlmICghaW1hZ2UuZ2lmTG9vcENvdW50KSB7XG4gICAgICAgICAgICBpbWFnZS5naWZMb29wQ291bnQgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIGltYWdlLmVycm9yID0gdHJ1ZTtcbiAgICB9XG4gICAgaW1hZ2UubG9hZGluZyA9IGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbIkludGVybGFjZU9mZnNldHMiLCJJbnRlcmxhY2VTdGVwcyIsIkJ5dGVTdHJlYW0iLCJvcmlnaW4iLCJ4IiwieSIsImRlZmF1bHRGcmFtZSIsImhhbGYiLCJpbml0aWFsVGltZSIsImZpcnN0SW5kZXgiLCJkZWZhdWx0TG9vcENvdW50IiwicGFyc2VDb2xvclRhYmxlIiwiYnl0ZVN0cmVhbSIsImNvdW50IiwiY29sb3JzIiwiaSIsInB1c2giLCJyIiwiZGF0YSIsInBvcyIsImciLCJiIiwicGFyc2VFeHRlbnNpb25CbG9jayIsImdpZiIsImdldEZyYW1lSW5kZXgiLCJnZXRUcmFuc3BhcmVuY3lJbmRleCIsIm5leHRCeXRlIiwiZnJhbWUiLCJmcmFtZXMiLCJwYWNrZWRCeXRlIiwiR0NyZXNlcnZlZCIsImRpc3Bvc2FsTWV0aG9kIiwidXNlcklucHV0RGVsYXlGbGFnIiwidHJhbnNwYXJlbmN5RmxhZyIsImRlbGF5VGltZSIsIm5leHRUd29CeXRlcyIsInRyYW5zcGFyZW5jeUluZGV4IiwiYXBwbGljYXRpb25FeHRlbnNpb24iLCJpZGVudGlmaWVyIiwiZ2V0U3RyaW5nIiwiYXV0aGVudGljYXRpb25Db2RlIiwicmVhZFN1YkJsb2Nrc0JpbiIsImFwcGxpY2F0aW9uRXh0ZW5zaW9ucyIsImNvbW1lbnRzIiwicmVhZFN1YkJsb2NrcyIsImdsb2JhbENvbG9yVGFibGUiLCJsZW5ndGgiLCJFdmFsRXJyb3IiLCJwbGFpblRleHREYXRhIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiY2hhclNpemUiLCJmb3JlZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ0ZXh0Iiwic2tpcFN1YkJsb2NrcyIsInBhcnNlSW1hZ2VCbG9jayIsImF2Z0FscGhhIiwicHJvZ3Jlc3NDYWxsYmFjayIsImxvY2FsQ29sb3JUYWJsZUZsYWciLCJpbnRlcmxhY2VkRmxhZyIsInNvcnRGbGFnIiwicmVzZXJ2ZWQiLCJsb2NhbENvbG9yQ291bnQiLCJsb2NhbENvbG9yVGFibGUiLCJnZXRDb2xvciIsImluZGV4IiwiYSIsImltYWdlIiwiSW1hZ2VEYXRhIiwiY29sb3JTcGFjZSIsImVycm9yIiwiRE9NRXhjZXB0aW9uIiwibmFtZSIsIm1pbkNvZGVTaXplIiwiaW1hZ2VEYXRhIiwiY2xlYXJDb2RlIiwicmVhZEJpdHMiLCJsZW4iLCJieXRlUG9zIiwiYml0UG9zIiwiY29kZSIsInNpemUiLCJkaWMiLCJwYXNzIiwicGl4ZWxQb3MiLCJsaW5lSW5kZXgiLCJleGl0IiwibGFzdCIsImNvbmNhdCIsIml0ZW0iLCJzZXQiLCJiaXRtYXAiLCJjcmVhdGVJbWFnZUJpdG1hcCIsInBhcnNlQmxvY2siLCJnZXRHSUZMb29wQW1vdW50IiwiZXh0ZW5zaW9uIiwiTmFOIiwiZGVjb2RlR0lGIiwiZ2lmVVJMIiwicmVzIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsImJ1ZmZlciIsImFycmF5QnVmZmVyIiwidG90YWxUaW1lIiwiY29sb3JSZXMiLCJwaXhlbEFzcGVjdFJhdGlvIiwiYmFja2dyb3VuZEltYWdlIiwiVWludDhDbGFtcGVkQXJyYXkiLCJFcnJvciIsImdsb2JhbENvbG9yVGFibGVGbGFnIiwiZ2xvYmFsQ29sb3JDb3VudCIsImJhY2tncm91bmRDb2xvckluZGV4IiwiY29weVdpdGhpbiIsImZyYW1lSW5kZXgiLCJpbmNyZW1lbnRGcmFtZUluZGV4IiwiZ2V0ZnJhbWVJbmRleCIsImluY3JlbWVudCIsIm5ld1ZhbHVlIiwiSW5maW5pdHkiLCJtZXNzYWdlIiwiZHJhd0dpZiIsImNvbnRleHQiLCJyYWRpdXMiLCJwYXJ0aWNsZSIsImRlbHRhIiwiZ2lmRGF0YSIsIm9mZnNjcmVlbkNhbnZhcyIsIk9mZnNjcmVlbkNhbnZhcyIsIm9mZnNjcmVlbkNvbnRleHQiLCJnZXRDb250ZXh0IiwiaW1hZ2VTbW9vdGhpbmdRdWFsaXR5IiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiY2xlYXJSZWN0IiwiZ2lmTG9vcENvdW50IiwidW5kZWZpbmVkIiwiZ2lmRnJhbWUiLCJnaWZUaW1lIiwic2NhbGUiLCJkcmF3SW1hZ2UiLCJwdXRJbWFnZURhdGEiLCJwcmV2aW91c0ltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsInZhbHVlIiwibG9hZEdpZkltYWdlIiwidHlwZSIsImxvYWRJbWFnZSIsImxvYWRpbmciLCJzb3VyY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tsparticles/shape-image/browser/GifUtils/Utils.js\n"));

/***/ })

}]);